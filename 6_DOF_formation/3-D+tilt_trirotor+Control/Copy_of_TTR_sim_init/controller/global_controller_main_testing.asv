function [des_from_ctrl,command,copter_cmd] = global_controller_main_testing(t, state, des_state, params)
%   CONTROLLER  Controller for the quadrotor 
%   todo -- 整体修改检查--加速度分解检查--Done 
%   state: The current state of the robot with the following fields:
%   state.pos = [x; y; z], state.vel = [x_dot; y_dot; z_dot] 
%   state.rot = [phi; theta; psi], state.omega = [p; q; r] 

%   加速度朝向顺序是[x, y, z]，分别对应东、北、天方向（ENU坐标系） 机头朝向 Y 
%   无人机模型的机头朝向是沿着机体坐标系的Y轴正方向，这符合 "右前上" (RFU)坐标系中Y轴指向前方的定义 

%%   Current state
%   phi = state.rot(1);
%   theta = state.rot(2);
%   psi = state.rot(3);
%   p = state.omega(1);
%   q = state.omega(2);
%   r = state.omega(3);


%%  des_state: The desired states are:
%   des_state.pos = [x; y; z], yaw_cmd = des_state.yaw，Va_cmd = des_state.Va
%   des_state.mode = [1]; 1 -- hovering  or 2 -- cruise or 3 -- transition
%   Using these current and desired states, you have to compute the desired
%   controls：des_from_ctrl = [vn_cmd, ve_cmd, vd_cmd, phi_cmd, theta_cmd, yaw_cmd, p_cmd, q_cmd, r_cmd, Mx_cmd, My_cmd, Mz_cmd];

mode = des_state.mode; % todo--轨迹添加顶层模式设置--done helix&step
controller = AircraftControl(params);
% 计算真空速（考虑风场影响）
u_r = state.vel(1) - params.w_es;
v_r = state.vel(2) - params.w_ns;
w_r = state.vel(3) - params.w_us;
Va = sqrt(u_r^2 + v_r^2 + w_r^2);
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% mode 1 copter 旋翼模式 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    if mode == 1
    %% Position control -- velocity_des from position error using PIDControl(class)世界坐标系下
    % PID gains from params ..... also the limits of every virables
    % pos_err = des_state.pos - state.pos; % 123-xyz-enu
    ve_cmd = controller.ve_from_pe.update(des_state.pos(1), state.pos(1)); % e
    vn_cmd = controller.vn_from_pn.update(des_state.pos(2), state.pos(2)); % n
    vu_cmd = controller.vu_from_pu.update(des_state.pos(3), state.pos(3)); % u
    
    
    %% velocity control -- attitudes cmd with acceleration_des from velocity error using PIDControl(class) 世界坐标系下
    
    % 123 xyz enu
    % 测试用
    % acc_des = [0,1,0]; % -- todo 修改坐标轴右手定则 东北天 enu -- done--todo --无执行器Done--有执行器--
    % test--done
    
    acc_des(1) = controller.acc_e_from_ve.update(ve_cmd, state.vel(1)); 
    acc_des(2) = controller.acc_n_from_vn.update(vn_cmd, state.vel(2));
    acc_des(3) = controller.acc_u_from_vu.update(vu_cmd, state.vel(3));
    
    
    
    %% 非线性 加速度到角度，解算
    % psi_cmd = des_state.yaw;
    psi_cmd = deg2rad(0);
    psi_cmd = wrap(psi_cmd, pi);  % 偏航角，[-pi, pi]
    
    % -- 完整非线性
    % 期望总推力向量（ENU坐标）
    F_des = params.mass * [acc_des(1); acc_des(2); params.gravity + acc_des(3)];
    
    % 期望机体Z轴方向 (Up)
    zb_des = F_des / norm(F_des);
    
    % 期望机体X轴水平投影方向
    xc = [sin(psi_cmd); cos(psi_cmd); 0];
    
    % 期望机体Y轴方向
    yb_des = cross(zb_des, xc);
    yb_des = yb_des / norm(yb_des);
    
    % 重新计算期望机体X轴方向，确保正交
    xb_des = cross(yb_des, zb_des);
    
    % 构造期望旋转矩阵
    R_des = [xb_des, yb_des, zb_des];
    
    % 解算欧拉角（ZXY顺序）
    roll_cmd = atan2(R_des(3,2), R_des(3,3));
    pitch_cmd = asin(R_des(3,1));
    
     % 姿态环测试用
    % phi_cmd= deg2rad(25);
    % theta_cmd= deg2rad(25);
    roll_cmd = wrap(roll_cmd, pi/3);      % 滚转角，[-pi/3., pi/3.]
    pitch_cmd = wrap(pitch_cmd, pi/3);  % 俯仰角，[-pi/3., pi/3.]
    
    % 避免奇异后限制范围
    roll_cmd = saturate(roll_cmd, -params.roll_input_limit, params.roll_input_limit);
    pitch_cmd = saturate(pitch_cmd, -params.pitch_input_limit, params.pitch_input_limit);
    
    % 期望合力转到机体坐标系 ENU -- RFU -- xyz--todo--Done
    % 测试
    force_cmd_body =  WorldToBodyAccel(F_des, state.rot(1),state.rot(2),state.rot(3)); % 高度控制映射机体坐标系
    
    
    %% attitude control -- p_cmd, q_cmd, r_cmd from accitudes error using PIDControl(class) 机体坐标系下
    
    % phi_cmd= deg2rad(15);
    % theta_cmd= deg2rad(15);
    % psi_cmd= deg2rad(0);
    p_cmd = controller.roll_rate_from_roll.update(roll_cmd, state.rot(1));
    q_cmd = controller.pitch_rate_from_pitch.update(pitch_cmd, state.rot(2));
    r_cmd = controller.yaw_rate_from_yaw.update(psi_cmd, state.rot(3));
    
    %% omega control-- xyz rfu 轴力矩 Mx_cmd, My_cmd, Mz_cmd from omega error using PIDControl(class) 机体坐标系下
    % todo -- 检查加速度方向分解对应-Done
    My_cmd = controller.My_from_roll_rate.update(p_cmd, state.omega(1)); %   with p_err    正滚转产生右正加速度（正反馈），所以加-
    Mx_cmd = controller.Mx_from_pitch_rate.update(q_cmd, state.omega(2)); %  with q_err    正俯仰产生前负加速度(负反馈)，
    Mz_cmd = controller.Mz_from_yaw_rate.update(r_cmd, state.omega(3)); %    with r_err    正偏航产生正力矩 没有加速度解算，合理
    
    moment_cmd_body = [My_cmd; Mx_cmd; Mz_cmd]; % roll pitch yaw
    
    % moment_cmd_body = [0; 0; Mz_cmd];  % 得到控制输出但是阻断 为0的是仅显示 不接动力学
    
    %% 期望状态输出 1 * 12 --- vel-att-omege-M
    % 可选替换 - ACC--Moment
    % des_from_ctrl = [ve_cmd, vn_cmd, vu_cmd, phi_cmd, theta_cmd, psi_cmd, p_cmd, q_cmd, r_cmd, M_y, M_x, M_z];
    des_from_ctrl = [ve_cmd, vn_cmd, vu_cmd, roll_cmd, pitch_cmd, psi_cmd, p_cmd, q_cmd, r_cmd, acc_des(1), acc_des(2), acc_des(3)];
    copter_cmd = [force_cmd_body; moment_cmd_body]; % 力与力矩期望
    
    % %% 执行器命令结算 -- 控制分配  - 机体坐标系 phi theta psi YXZ 前右上 roll pitch yaw 储存顺序
    command = actuator_assignment(force_cmd_body, moment_cmd_body, state, params, mode);

    end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% mode 2 copter2cruise 过渡模式 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    if mode == 2
    % 测试用
    acc_des = [0,4,0]; % --todo--定高切换 + 倾转切换 + 姿态稳定
    roll_cmd = 0;
    pitch_cmd = 0; 
    % psi_cmd = des_state.yaw;
    psi_cmd = deg2rad(0);
    psi_cmd = wrap(psi_cmd, pi);  % 偏航角，[-pi, pi]
    F_des = params.mass * [acc_des(1); acc_des(2); params.gravity + acc_des(3)];

    % 期望合力转到机体坐标系 ENU -- RFU
    force_cmd_body =  WorldToBodyAccel(F_des, state.rot(1),state.rot(2),state.rot(3)); % 高度控制映射机体坐标系
    
    
    %% attitude control -- p_cmd, q_cmd, r_cmd from accitudes error using PIDControl(class) 机体坐标系下
    p_cmd = controller.roll_rate_from_roll.update(roll_cmd, state.rot(1));
    q_cmd = controller.pitch_rate_from_pitch.update(pitch_cmd, state.rot(2));
    r_cmd = controller.yaw_rate_from_yaw.update(psi_cmd, state.rot(3));
    
    %% omega control-- xyz rfu 轴力矩 Mx_cmd, My_cmd, Mz_cmd from omega error using PIDControl(class) 机体坐标系下
    % todo -- 检查加速度方向分解对应-Done
    My_cmd = controller.My_from_roll_rate.update(p_cmd, state.omega(1)); %   with p_err    正滚转产生右正加速度（正反馈），所以加-
    Mx_cmd = controller.Mx_from_pitch_rate.update(q_cmd, state.omega(2)); %  with q_err    正俯仰产生前负加速度(负反馈)，
    Mz_cmd = controller.Mz_from_yaw_rate.update(r_cmd, state.omega(3)); %    with r_err    正偏航产生正力矩 没有加速度解算，合理
    
    moment_cmd_body = [My_cmd; Mx_cmd; Mz_cmd]; % roll pitch yaw
    
    %% 期望状态输出 1 * 12 --- vel-att-omege-M
    % 可选替换 - ACC--Moment
    % des_from_ctrl = [ve_cmd, vn_cmd, vu_cmd, phi_cmd, theta_cmd, psi_cmd, p_cmd, q_cmd, r_cmd, M_y, M_x, M_z];
    des_from_ctrl = [v_r, u_r, Va, roll_cmd, pitch_cmd, psi_cmd, p_cmd, q_cmd, r_cmd, acc_des(1), acc_des(2), acc_des(3)];
    copter_cmd = [force_cmd_body; moment_cmd_body]; % 力与力矩期望

    
    % %% 执行器命令结算 -- 控制分配  - 机体坐标系 phi theta psi YXZ 前右上 roll pitch yaw 储存顺序
    command = actuator_assignment(force_cmd_body, moment_cmd_body, state, params, mode);

    end



% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %% mode 3 cruise 固定翼模式 优化版本
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    if mode == 3 
        if nargin < 6
        end

    % 期望航向角计算（使用更稳定的导航算法）
    dx = des_state.pos(1) - state.pos(1);
    dy = des_state.pos(2) - state.pos(2);
    
    % 使用 atan2 计算期望航向角，东北天与右前上坐标系框架
    yaw_cmd = -wrapToPi(atan2(dx, dy));
    yaw_cmd = deg2rad(0); % test
    % 速度控制（增加饱和和平滑）
    throttle = saturate(controller.throttle_from_airspeed.update(des_state.Va, Va), 0, 2);
    ta = throttle/2;
    tb = ta;
    tc = 0;
    
    % 高度控制（增加前馈和微分项）
    pitch_cmd = controller.pitch_from_altitude.update(des_state.pos(3), state.pos(3));    
    pitch_cmd = deg2rad(0);% test
    % 横滚角控制（引入交叉误差） % 坐标系补偿修正 正滚转 负偏航  
    roll_cmd_1 = -(controller.roll_from_course.update(yaw_cmd, state.rot(3))) ;
    roll_cmd =  deg2rad(0); % test
    % 限制横滚角在合理范围
    roll_cmd = saturate(roll_cmd, deg2rad(-30), deg2rad(30));
    
    % 升降舵和副翼控制
    Mx_cmd = controller.elevator_from_pitch.update(pitch_cmd, state.rot(2), state.omega(2));
    My_cmd = controller.aileron_from_roll.update(roll_cmd, state.rot(1), state.omega(1));
    
    % 升降舵和副翼混合控制
    elevon_r = -(Mx_cmd + My_cmd);
    elevon_l = -(Mx_cmd - My_cmd);
    
    % 控制面限幅
    elevon_r = saturate(elevon_r, deg2rad(-45), deg2rad(45));
    elevon_l = saturate(elevon_l, deg2rad(-45), deg2rad(45));
    
    % 倾转角度
    arm_a = deg2rad(90);
    arm_b = arm_a;    

    % 避免奇异
    roll_cmd = wrap(roll_cmd, pi/3);      % 滚转角，[-pi/3., pi/3.]
    pitch_cmd = wrap(pitch_cmd, pi/3);  % 俯仰角，[-pi/3., pi/3.]
    
    % 避免奇异后限制范围
    roll_cmd = saturate(roll_cmd, -params.roll_input_limit, params.roll_input_limit);
    pitch_cmd = saturate(pitch_cmd, -params.pitch_input_limit, params.pitch_input_limit);
    % 命令输出
    command.throttle = [ta, tb, tc];
    command.elevon = [elevon_r, elevon_l];
    % command.elevon = [0, 0];
    command.arm = [arm_a, arm_b];
    
    % 输出期望状态 (1 * 12)
    s = [state.pos(1),state.pos(2),state.pos(3),state.vel(1),state.vel(2),state.vel(3),0,0,0,0,state.omega(1),state.omega(2),state.omega(3),];
    [force, moment] = all_forces_moments(s, command, params);

    copter_cmd = [force; moment]; % 
    des_from_ctrl = [Va, des_state.Va, 0, roll_cmd, pitch_cmd, yaw_cmd, 0, 0, 0, moment(1), moment(2), moment(3)];

    end
    % disp(mode);

end

% 辅助函数：数值饱和
function y = saturate(x, low, high)
    y = max(low, min(x, high));
end

% 辅助函数：角度限制在 [-pi, pi]
function angle = wrapToPi(angle)
    angle = mod(angle + pi, 2*pi) - pi;
end


% % moment = [My_cmd; Mx_cmd; 0]; % roll pitch yaw;
% moment(3) = 0.1*roll_cmd_1;