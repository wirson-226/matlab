% %% 修改后的编队协议主函数
% function y = threeFollowers_IAPF2022_simulation(t, X, ctrl, all_obs)
%     % 从ctrl结构体中提取参数
%     w = ctrl.w; r = ctrl.r;
%     w_lead = ctrl.w_lead; r_lead = ctrl.r_lead;
%     K1 = ctrl.K1;
%     K_1 = ctrl.K_1; K_2 = ctrl.K_2;
%     c_1 = ctrl.c_1; c_2 = ctrl.c_2;
%     k_rep = ctrl.k_rep; k_rot = ctrl.k_rot; k_damp = ctrl.k_damp;
%     r_safe = ctrl.r_safe;
% 
%     % 系统矩阵
%     A = [0 1; 0 0]; B = [0; 1];
%     H = zeros(3,3); H(1,1) = 2;  % H必须是3×3矩阵
%     D = eye(3);
%     L_H = [4 -1 -1; -1 1 0; -1 0 1];
%     N_1 = ones(3,1);
% 
%     y = zeros(16,1);
% 
%     % === Leader控制 ===
%     leader_ref = calcul_singledrone_h(w_lead, r_lead, t);
%     leader_ref_dot = calcul_singledrone_hDer(w_lead, r_lead, t);
% 
%     U0 = kron(eye(2),K1)*(X(1:4) - leader_ref) + ...
%          kron(eye(2),[0 1])*leader_ref_dot;
%     y(1:4) = kron(eye(2),A)*X(1:4) + kron(eye(2),B)*U0;
% 
%     % === Follower编队控制 ===
%     formation_ref = calcul_three_formation_h(w, r, t);
% 
% 
%     % 分步计算以确保维度正确
%     X_followers = X(5:16);  % 12×1
% 
%     % 第一项：跟随项
%     U_term1 = kron(eye(3), kron(eye(2), K_1)) * (X_followers - kron(D*N_1, X(1:4)));
% 
%     % 第二项：编队项
%     U_term2 = c_1 * kron(L_H, kron(eye(2), K_2)) * (X_followers - formation_ref);
% 
%     % 第三项：修正项
%     U_term3 = c_1 * kron(eye(3), kron(eye(2), K_2)) * kron(D*H*N_1, X(1:4));
% 
%     % 第四项：滑模项
%     sliding_surface = kron(L_H, kron(eye(2), K_2)) * (X_followers - formation_ref) - ...
%                      kron(eye(3), kron(eye(2), K_2)) * kron(D*H*N_1, X(1:4));
%     % U_term4 = c_2 * sign(sliding_surface);
%     % 效果
%     % < 0.05	抖动大、接近 sign()
%     % 0.05–0.15	平衡控制强度与平滑性
%     % > 0.2	抑制抖动强，控制滞后
%     epsilon = 0.08;  % 可调边界层参数，越小越接近 sign()，但越容易抖动ε值	
%     U_term4 = c_2 * tanh(sliding_surface / epsilon);
% 
% 
%     % 合成控制
%     U_foll = U_term1 + U_term2 - U_term3 + U_term4;
% 
%     % === 改进APF避障项 ===
% 
%     obstacles = all_obs;
%     U_apf_total = zeros(6,1);
% 
%     for i = 1:3
%         % 正确的索引：follower i 对应 X(4*i+1:4*i+4)
%         start_idx = 4*i + 1;
%         pos = [X(start_idx), X(start_idx+2)]';     % [x, y]
%         vel = [X(start_idx+1), X(start_idx+3)]';   % [vx, vy]
% 
%         F_rep_total = [0; 0];
%         F_rot_total = [0; 0];
% 
%         if size(obstacles, 1) >= 2  % 确保obstacles至少有2行
%             for j = 1:size(obstacles,2)
%                 obs = obstacles(j,:)';
%                 % fprintf('pos =\n');
%                 % disp(pos);
%                 % fprintf('obs =\n');
%                 % disp(obs);
%                 diff = pos - obs;
%                 dist = norm(diff);
% 
%                 if dist < r_safe && dist > 1e-3
%                     F_rep = k_rep * (1/dist - 1/r_safe) * (1/dist^3) * diff;
%                     F_rep_total = F_rep_total + F_rep;
% 
%                     e_z = [0; 0; 1];
%                     rot_dir = cross([diff; 0], e_z);
%                     F_rot = k_rot * (rot_dir(1:2) / (dist^2));
%                     F_rot_total = F_rot_total + F_rot;
%                 end
%             end
%         end
% 
%         F_damp = -k_damp * vel;
%         U_apf = F_rep_total + F_rot_total + F_damp;
%         U_apf_total(2*i-1:2*i) = U_apf;
%     end
% 
%     U_foll = U_foll + U_apf_total;
% 
%     % === Follower动态更新 ===
%     y(5:16) = kron(eye(6),A)*X(5:16) + kron(eye(6),B)*U_foll;
% end
